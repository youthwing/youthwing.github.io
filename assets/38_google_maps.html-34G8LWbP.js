import{_ as e,o as a,c as t,e as n}from"./app-pTviJk1n.js";const s="/assets/system-design-206-DL_gV0B7.png",o="/assets/system-design-207-rqpRqdLW.png",i="/assets/system-design-208-cEky32BI.png",r="/assets/system-design-209-Y420FL2p.png",l="/assets/system-design-210-MP2ASPV1.png",d="/assets/system-design-211-rOD_fZ5h.png",u="/assets/system-design-212-AT5sCJ3Y.png",c="/assets/system-design-213-_tvl5JCs.png",p="/assets/system-design-214-ReWfQz8T.png",g="/assets/system-design-215-dQaW0Cn3.png",h="/assets/system-design-216-DZ8lbKaT.png",m="/assets/system-design-217-a_sdh05J.png",v="/assets/system-design-218-rtwMLSw0.png",b="/assets/system-design-219-_-w3xqcp.png",q="/assets/system-design-220-PF0D9mMw.png",f="/assets/system-design-221-H6W5ZlQy.png",_="/assets/system-design-222-_TY8FLpS.png",x="/assets/system-design-224-MfpJYs9Z.png",y="/assets/system-design-225-pQyRylyE.png",z="/assets/system-design-226-T1LZOlrZ.png",A="/assets/system-design-227-PqAt4uQ3.png",w={},S=n('<h1 id="_18-设计-google-maps" tabindex="-1"><a class="header-anchor" href="#_18-设计-google-maps" aria-hidden="true">#</a> 18. 设计 Google Maps</h1><p>我们将设计一个简化版本的 Google Maps。</p><p>关于 Google Maps 的一些事实：</p><ul><li>启动于 2005 年</li><li>提供各种服务：卫星影像、街道地图、实时交通状况、路线规划</li><li>到 2021 年，拥有 10 亿日活跃用户，全球覆盖率为 99%，每天更新 2500 万条实时位置信息</li></ul><h2 id="第一步-理解问题并确定设计范围" tabindex="-1"><a class="header-anchor" href="#第一步-理解问题并确定设计范围" aria-hidden="true">#</a> 第一步：理解问题并确定设计范围</h2><p>候选人和面试官之间的问答示例：</p><ul><li><strong>候选人</strong>: 我们要处理多少日活跃用户？</li><li><strong>面试官</strong>: 10 亿 DAU</li><li><strong>候选人</strong>: 我们应该专注于哪些功能？</li><li><strong>面试官</strong>: 位置信息更新、导航、预计到达时间 (ETA)、地图渲染</li><li><strong>候选人</strong>: 路况数据有多大？我们可以访问吗？</li><li><strong>面试官</strong>: 我们从多个来源获得了路况数据，原始数据为 TB 级</li><li><strong>候选人</strong>: 我们需要考虑交通状况吗？</li><li><strong>面试官</strong>: 是的，考虑交通状况是必要的，以便提供准确的时间估算</li><li><strong>候选人</strong>: 那不同的出行方式（步行、骑行、驾车）呢？</li><li><strong>面试官</strong>: 我们应该支持这些</li><li><strong>候选人</strong>: 多站点的路线规划呢？</li><li><strong>面试官</strong>: 这部分我们不考虑，面试范围内不讨论</li><li><strong>候选人</strong>: 商业地点和照片呢？</li><li><strong>面试官</strong>: 好问题，但不需要考虑这些</li></ul><p>我们将专注于三个关键功能：用户位置更新、导航服务（包括 ETA）、地图渲染。</p><h3 id="非功能性需求" tabindex="-1"><a class="header-anchor" href="#非功能性需求" aria-hidden="true">#</a> 非功能性需求</h3><ul><li>准确性：用户不应获得错误的导航路线</li><li>平滑导航：用户应该体验到平滑的地图渲染</li><li>数据和电池使用：客户端应尽可能少地使用数据和电池，对于移动设备尤为重要。</li><li>一般的可用性和可扩展性需求</li></ul><h3 id="粗略估算" tabindex="-1"><a class="header-anchor" href="#粗略估算" aria-hidden="true">#</a> 粗略估算</h3><p>对于存储，我们需要存储：</p><ul><li>世界地图：估计为 ~70PB，考虑到所有需要存储的切片，并且对非常相似的切片（例如广阔的沙漠）进行压缩</li><li>元数据：大小可以忽略，因此我们不计算</li><li>路况信息：以（routing tiles）形式存储</li></ul><p>估计的导航请求 QPS：</p><ul><li>10 亿日活跃用户，每周使用 35 分钟 -&gt; 每天 50 亿分钟。</li><li>假设 GPS 更新请求是批量处理的，得出 QPS 为 20 万；</li><li>峰值负载时 QPS 为 100 万。</li></ul><hr><p>在进入设计之前，有一些与地图相关的概念我们需要理解。</p><h3 id="定位系统" tabindex="-1"><a class="header-anchor" href="#定位系统" aria-hidden="true">#</a> 定位系统</h3><p>地球是一个球体，围绕其轴线旋转。位置由纬度（指示你离赤道的距离）和经度（指示你离本初子午线的距离）来定义：</p><figure><img src="'+s+'" alt="partitioning-system" tabindex="0" loading="lazy"><figcaption>partitioning-system</figcaption></figure><h3 id="从-3d-到-2d" tabindex="-1"><a class="header-anchor" href="#从-3d-到-2d" aria-hidden="true">#</a> 从 3D 到 2D</h3><p>将 3D 坐标转换为 2D 平面的过程称为“地图投影”。</p><p>有不同的方法来实现这一点，每种方法都有其优缺点。几乎所有的方法都会扭曲实际的几何形状。</p><figure><img src="'+o+'" alt="map-projections" tabindex="0" loading="lazy"><figcaption>map-projections</figcaption></figure><p>Google Maps 选择了 Mercator 投影的修改版，称为“Web Mercator”。</p><h3 id="地理编码-geocoding" tabindex="-1"><a class="header-anchor" href="#地理编码-geocoding" aria-hidden="true">#</a> 地理编码（Geocoding）</h3><p>地理编码是将地址转换为地理坐标的过程。</p><p>反向过程称为“反向地理编码”。</p><p>实现这一过程的一种方式是使用插值：利用来自不同来源的数据（如 GIS）将街道网络映射到地理坐标空间。</p><h3 id="地理哈希-geohashing" tabindex="-1"><a class="header-anchor" href="#地理哈希-geohashing" aria-hidden="true">#</a> 地理哈希（Geohashing）</h3><p>地理哈希是一种编码系统，它将一个地理区域编码成由字母和数字组成的字符串。</p><p>它将地球视为一个平坦的表面，并递归地将其划分为四个象限：</p><figure><img src="'+i+'" alt="geohashing" tabindex="0" loading="lazy"><figcaption>geohashing</figcaption></figure><h3 id="地图渲染" tabindex="-1"><a class="header-anchor" href="#地图渲染" aria-hidden="true">#</a> 地图渲染</h3><p>地图渲染通过切片进行，我们没有选择将整个地图作为一张大的自定义图像渲染，而是将世界分解成更小的切片。</p><p>客户端只下载相关的切片，并像拼接拼图一样进行渲染。</p><p>不同的缩放级别有不同的切片，客户端根据缩放级别选择合适的切片。</p><p>例如，缩小到全球视图时，只会下载一张 256x256 的切片，代表整个世界。</p><h3 id="导航算法中的道路数据处理" tabindex="-1"><a class="header-anchor" href="#导航算法中的道路数据处理" aria-hidden="true">#</a> 导航算法中的道路数据处理</h3><p>在大多数路径规划算法中，道路被抽象成一个图（graph），交叉点表示为节点，道路表示为边：</p><figure><img src="'+r+'" alt="road-representation" tabindex="0" loading="lazy"><figcaption>road-representation</figcaption></figure><p>大多数导航算法使用修改版的 Dijkstra 或 A* 算法。</p><p>路径寻找性能对图的大小非常敏感，为了支持大规模应用，我们不能将整个世界表示为一个图并在其上运行算法。</p><p>相反，我们采用类似于切片的技术：将世界划分为越来越小的图。</p><p>路由切片（Routing Tiles）持有相邻切片的引用，算法可以在遍历相互连接的切片时，将更大的道路图拼接起来：</p><figure><img src="'+l+'" alt="routing-tiles" tabindex="0" loading="lazy"><figcaption>routing-tiles</figcaption></figure><p>这种技术使我们能够显著减少内存带宽，只加载我们需要的切片来处理给定的起点/终点对。</p><p>然而，对于较长的路线，拼接小而详细的（routing tiles）仍然会消耗时间和内存。为了解决这个问题，我们使用具有不同详细程度的（routing tiles），并根据目的地选择适当详细程度的切片：</p><figure><img src="'+d+'" alt="map-routing-hierarchical" tabindex="0" loading="lazy"><figcaption>map-routing-hierarchical</figcaption></figure><h2 id="第二步-提出高层设计并获得认可" tabindex="-1"><a class="header-anchor" href="#第二步-提出高层设计并获得认可" aria-hidden="true">#</a> 第二步：提出高层设计并获得认可</h2><figure><img src="'+u+'" alt="high-level-design" tabindex="0" loading="lazy"><figcaption>high-level-design</figcaption></figure><h3 id="位置服务-location-service" tabindex="-1"><a class="header-anchor" href="#位置服务-location-service" aria-hidden="true">#</a> 位置服务（Location service）</h3><figure><img src="'+c+'" alt="location-service" tabindex="0" loading="lazy"><figcaption>location-service</figcaption></figure><p>位置服务负责记录用户的位置信息更新：</p><ul><li>每 <code>t</code> 秒发送一次位置更新</li><li>位置数据流可用于逐步改进服务，例如提供更准确的 ETA、监控交通数据、检测封闭道路、分析用户行为等</li></ul><p>为了避免每次都向服务器发送位置更新，我们可以在客户端批量更新并发送批量数据：</p><figure><img src="'+p+`" alt="location-update-batches" tabindex="0" loading="lazy"><figcaption>location-update-batches</figcaption></figure><p>尽管进行了优化，但对于像 Google Maps 这样规模的系统，负载仍然会很大。因此，我们可以使用像 Cassandra 这样的数据库，它对高频写入进行了优化。</p><p>我们还可以利用 Kafka 来高效处理位置更新流，以便进一步分析。</p><p>位置更新请求示例：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>POST /v1/locations
参数
  locs: JSON 编码的 (纬度，经度，时间戳) 元组数组。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="导航服务-navigation-service" tabindex="-1"><a class="header-anchor" href="#导航服务-navigation-service" aria-hidden="true">#</a> 导航服务（Navigation service）</h3><p>导航组件负责在合理的时间内找到 A 和 B 之间的快速路线（少量延迟是可以接受的）。路线不必是最快的，但准确性至关重要。</p><p>请求负载示例：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>GET /v1/nav?origin=1355+market+street,SF&amp;destination=Disneyland
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>响应示例：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{
  &quot;distance&quot;: {&quot;text&quot;:&quot;0.2 mi&quot;, &quot;value&quot;: 259},
  &quot;duration&quot;: {&quot;text&quot;: &quot;1 min&quot;, &quot;value&quot;: 83},
  &quot;end_location&quot;: {&quot;lat&quot;: 37.4038943, &quot;Ing&quot;: -121.9410454},
  &quot;html_instructions&quot;: &quot;Head &lt;b&gt;northeast&lt;/b&gt; on &lt;b&gt;Brandon St&lt;/b&gt; toward &lt;b&gt;Lumin Way&lt;/b&gt;&lt;div style=\\&quot;font-size:0.9em\\&quot;&gt;Restricted usage road&lt;/div&gt;&quot;,
  &quot;polyline&quot;: {&quot;points&quot;: &quot;_fhcFjbhgVuAwDsCal&quot;},
  &quot;start_location&quot;: {&quot;lat&quot;: 37.4027165, &quot;lng&quot;: -121.9435809},
  &quot;geocoded_waypoints&quot;: [
    {
       &quot;geocoder_status&quot; : &quot;OK&quot;,
       &quot;partial_match&quot; : true,
       &quot;place_id&quot; : &quot;ChIJwZNMti1fawwRO2aVVVX2yKg&quot;,
       &quot;types&quot; : [ &quot;locality&quot;, &quot;political&quot; ]
    },
    {
       &quot;geocoder_status&quot; : &quot;OK&quot;,
       &quot;partial_match&quot; : true,
       &quot;place_id&quot; : &quot;ChIJ3aPgQGtXawwRLYeiBMUi7bM&quot;,
       &quot;types&quot; : [ &quot;locality&quot;, &quot;political&quot; ]
    }
  ],
  &quot;travel_mode&quot;: &quot;DRIVING&quot;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>交通变化和重新规划路径将在深入分析部分讨论。</p><h3 id="地图渲染-1" tabindex="-1"><a class="header-anchor" href="#地图渲染-1" aria-hidden="true">#</a> 地图渲染</h3><p>在客户端存储整个地图数据集是不可行的，因为它的大小是 PB 级的。</p><p>这些数据需要根据客户端的位置和缩放级别按需从服务器获取。</p><p>何时应获取新切片：用户在缩放地图，或导航时向新切片前进时。</p><p>如何将地图切片提供给客户端？</p><ul><li>可以动态构建，但这会给服务器带来巨大的负载，并且使缓存变得困难</li><li>地图切片可以根据地理哈希静态提供，客户端可以计算这些哈希。它们可以</li></ul><p>被静态存储，并通过 CDN 提供</p><figure><img src="`+g+'" alt="static-map-tiles" tabindex="0" loading="lazy"><figcaption>static-map-tiles</figcaption></figure><p>CDN 使得用户可以从最靠近用户的服务节点（POP）获取地图切片，以减少延迟：</p><figure><img src="'+h+'" alt="cdn-vs-no-cdn" tabindex="0" loading="lazy"><figcaption>cdn-vs-no-cdn</figcaption></figure><p>决定地图切片的选项：</p><ul><li>地图切片的地理哈希可以在客户端计算。如果是这种方式，我们应该长期支持这种地图切片计算方式，保证应用更新时的后向兼容，因为引导用户更新客户端是困难的。</li><li>另外，我们可以提供一个简单的 API，计算地图切片的 URL，并为客户端提供服务，代价是额外的 API 调用</li></ul><figure><img src="'+m+'" alt="map-tile-url-calculation" tabindex="0" loading="lazy"><figcaption>map-tile-url-calculation</figcaption></figure><h2 id="第三步-设计深度分析" tabindex="-1"><a class="header-anchor" href="#第三步-设计深度分析" aria-hidden="true">#</a> 第三步：设计深度分析</h2><h3 id="数据模型" tabindex="-1"><a class="header-anchor" href="#数据模型" aria-hidden="true">#</a> 数据模型</h3><p>首先，我们来讨论如何存储系统所处理的不同类型的数据。</p><h4 id="路由切片" tabindex="-1"><a class="header-anchor" href="#路由切片" aria-hidden="true">#</a> 路由切片</h4><p>初始的道路数据集来自不同的来源，随着位置更新数据的不断增加，数据会逐渐得到改进。</p><p>道路数据是非结构化的。我们有一个周期性的离线处理任务，将这些原始数据转换为我们应用程序需要的基于图的路由切片。</p><p>我们不需要使用数据库来存储这些切片，因为我们不需要任何数据库的功能。我们可以将它们存储在 S3 对象存储中，并进行积极的缓存。</p><p>我们还可以利用库将邻接列表有效地压缩成二进制文件。</p><h4 id="用户位置数据" tabindex="-1"><a class="header-anchor" href="#用户位置数据" aria-hidden="true">#</a> 用户位置数据</h4><p>用户位置数据对更新交通状况和进行各种其他分析非常有用。</p><p>我们可以使用 Cassandra 来存储这类数据，因为它的特点是写入频繁。</p><p>示例行：</p><figure><img src="'+v+'" alt="user-location-data-row" tabindex="0" loading="lazy"><figcaption>user-location-data-row</figcaption></figure><h4 id="地理编码数据库" tabindex="-1"><a class="header-anchor" href="#地理编码数据库" aria-hidden="true">#</a> 地理编码数据库</h4><p>这个数据库存储经纬度对和地点之间的键值对。</p><p>我们可以使用 Redis，因为它具有快速的读取访问速度，而我们的读取频繁且写入不多。</p><h4 id="预计算的世界地图图像" tabindex="-1"><a class="header-anchor" href="#预计算的世界地图图像" aria-hidden="true">#</a> 预计算的世界地图图像</h4><p>如前所述，我们将预计算地图切片图像并将其存储在 CDN 中。</p><figure><img src="'+b+'" alt="precomputed-map-tile-image" tabindex="0" loading="lazy"><figcaption>precomputed-map-tile-image</figcaption></figure><h3 id="位置服务" tabindex="-1"><a class="header-anchor" href="#位置服务" aria-hidden="true">#</a> 位置服务</h3><p>接着，让我们专注于数据库设计，并详细说明如何存储用户位置数据。</p><figure><img src="'+q+'" alt="location-service-diagram" tabindex="0" loading="lazy"><figcaption>location-service-diagram</figcaption></figure><p>我们可以使用 NoSQL 数据库来支持我们在位置更新上的重写负载。我们优先考虑可用性而非一致性，因为用户位置数据经常发生变化，容易过时。</p><p>我们将选择 Cassandra 作为我们的数据库选择，因为它很好地满足了我们的所有需求。</p><p>我们将存储的示例行：</p><figure><img src="'+f+'" alt="user-location-row-example" tabindex="0" loading="lazy"><figcaption>user-location-row-example</figcaption></figure><ul><li><code>user_id</code> 是分区键，用于快速访问特定用户的所有位置更新</li><li><code>timestamp</code> 是聚类键，用于按位置更新接收的时间对数据进行排序</li></ul><p>我们还利用 Kafka 将位置更新流式传输到其他需要位置更新的服务：</p><figure><img src="'+_+'" alt="location-update-streaming" tabindex="0" loading="lazy"><figcaption>location-update-streaming</figcaption></figure><h3 id="渲染地图" tabindex="-1"><a class="header-anchor" href="#渲染地图" aria-hidden="true">#</a> 渲染地图</h3><p>地图切片存储在不同的缩放级别下，在最低缩放级别，整个世界由一个 256x256 的切片表示。</p><p>随着缩放级别的增加，地图切片的数量增加四倍：</p><figure><img src="'+i+'" alt="zoom-level-increases" tabindex="0" loading="lazy"><figcaption>zoom-level-increases</figcaption></figure><p>我们可以使用的一种优化方法是，不通过网络发送整个图像信息，而是将切片表示为向量（路径和多边形），并让客户端动态渲染切片。</p><p>这将大大节省带宽。</p><h3 id="导航服务" tabindex="-1"><a class="header-anchor" href="#导航服务" aria-hidden="true">#</a> 导航服务</h3><p>导航服务负责找到最快的路线：</p><figure><img src="'+x+`" alt="navigation-service" tabindex="0" loading="lazy"><figcaption>navigation-service</figcaption></figure><p>让我们逐个查看这个子系统中的每个组件。</p><p>首先，我们有地理编码服务，它将地址解析为经纬度对的位置。</p><p>示例请求：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>示例响应：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{
   &quot;results&quot; : [
      {
         &quot;formatted_address&quot; : &quot;1600 Amphitheatre Parkway, Mountain View, CA 94043, USA&quot;,
         &quot;geometry&quot; : {
            &quot;location&quot; : {
               &quot;lat&quot; : 37.4224764,
               &quot;lng&quot; : -122.0842499
            },
            &quot;location_type&quot; : &quot;ROOFTOP&quot;,
            &quot;viewport&quot; : {
               &quot;northeast&quot; : {
                  &quot;lat&quot; : 37.4238253802915,
                  &quot;lng&quot; : -122.0829009197085
               },
               &quot;southwest&quot; : {
                  &quot;lat&quot; : 37.4211274197085,
                  &quot;lng&quot; : -122.0855988802915
               }
            }
         },
         &quot;place_id&quot; : &quot;ChIJ2eUgeAK6j4ARbn5u_wAGqWA&quot;,
         &quot;plus_code&quot;: {
            &quot;compound_code&quot;: &quot;CWC8+W5 Mountain View, California, United States&quot;,
            &quot;global_code&quot;: &quot;849VCWC8+W5&quot;
         },
         &quot;types&quot; : [ &quot;street_address&quot; ]
      }
   ],
   &quot;status&quot; : &quot;OK&quot;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>路线规划服务根据当前的交通状况计算建议路线，优化旅行时间。</p><p>最短路径服务运行一种变种的 A* 算法，在对象存储中的路由切片上计算最优路径：</p><ul><li>它接收源/目的地对，将其转换为经纬度对，并从这些对中推导出地理哈希，以确定路由切片</li><li>算法从初始路由切片开始，开始遍历直到找到一个到目的地切片的合理路径</li></ul><figure><img src="`+y+`" alt="shortest-path-service" tabindex="0" loading="lazy"><figcaption>shortest-path-service</figcaption></figure><p>ETA 服务被路线规划服务调用，以基于机器学习算法根据交通数据预测 ETA（预计到达时间）。</p><p>排序服务负责根据用户传递的过滤器对不同的路径进行排序，比如避免收费公路或高速公路等标志。</p><p>更新服务异步更新一些重要的数据库，以保持它们的最新状态。</p><h3 id="改进-自适应-eta-和重新规划路线" tabindex="-1"><a class="header-anchor" href="#改进-自适应-eta-和重新规划路线" aria-hidden="true">#</a> 改进 - 自适应 ETA 和重新规划路线</h3><p>我们可以进行的一项改进是，根据新获取的交通数据自适应更新正在进行的路线。</p><p>一种实现方式是，通过存储用户正在导航的路线中的所有切片，将这些用户存储在数据库中。</p><p>数据可能如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>user_1: r_1, r_2, r_3, …, r_k
user_2: r_4, r_6, r_9, …, r_n
user_3: r_2, r_8, r_9, …, r_m
...
user_n: r_2, r_10, r21, ..., r_l
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果某个切片发生交通事故，我们可以识别出所有经过该切片的用户，并重新规划他们的路线。</p><p>为了减少我们在数据库中存储的切片数量，我们可以改为存储起始路由切片和几个不同分辨率级别的路由切片，直到目的地切片也被包含在内：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>user_1, r_1, super(r_1), super(super(r_1)), ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+z+'" alt="adaptive-eta-data-storage" tabindex="0" loading="lazy"><figcaption>adaptive-eta-data-storage</figcaption></figure><p>通过这种方式，我们只需要检查用户的最终切片是否包含交通事故的切片，从而判断用户是否受到影响。</p><p>我们还可以跟踪正在导航的用户的所有可能路线，并在有更快的重新规划路径时通知他们。</p><h3 id="传输协议" tabindex="-1"><a class="header-anchor" href="#传输协议" aria-hidden="true">#</a> 传输协议</h3><p>我们有几种选择，可以让我们主动从服务器向客户端推送数据：</p><ul><li>移动推送通知不适用，因为负载有限，且不适用于 Web 应用</li><li>WebSocket 通常比长轮询更好，因为它对服务器的计算负担较小</li><li>我们还可以使用服务器推送事件（SSE），但更倾向于使用 WebSocket，因为它支持双向通信，这在例如最后一公里配送功能中非常有用</li></ul><h2 id="第四步-总结" tabindex="-1"><a class="header-anchor" href="#第四步-总结" aria-hidden="true">#</a> 第四步：总结</h2><p>这是我们的最终设计：</p><figure><img src="'+A+'" alt="final-design" tabindex="0" loading="lazy"><figcaption>final-design</figcaption></figure><p>我们可以提供的一个附加功能是多站点导航，这可以出售给像 Uber 或 Lyft 这样的企业客户，以确定访问一组位置的最优路径。</p>',150),C=[S];function P(M,D){return a(),t("div",null,C)}const W=e(w,[["render",P],["__file","38_google_maps.html.vue"]]);export{W as default};

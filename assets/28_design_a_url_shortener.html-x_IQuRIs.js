import{_ as r,o as e,c as t,f as a,e as i}from"./app-muG4J4_9.js";const n="/assets/system-design-74-EBKLEH-v.png",l="/assets/system-design-75-Y8APXo1X.png",s="/assets/system-design-76-mMwpglnu.png",o="/assets/system-design-77-gVHMQUQU.png",d="/assets/system-design-78-n-HuYJrn.png",h={},g=i('<h1 id="_8-设计-tinyurl-系统" tabindex="-1"><a class="header-anchor" href="#_8-设计-tinyurl-系统" aria-hidden="true">#</a> 8. 设计 TinyUrl 系统</h1><p>这是一个经典的系统设计问题：设计一个类似 TinyURL 的 URL 短链接服务。</p><h2 id="第一步-理解问题并明确设计范围" tabindex="-1"><a class="header-anchor" href="#第一步-理解问题并明确设计范围" aria-hidden="true">#</a> 第一步：理解问题并明确设计范围</h2><ul><li><p><strong>候选人</strong>：URL 短链接服务如何工作？</p></li><li><p><strong>面试官</strong>：给定 URL <code>https://www.systeminterview.com/q=chatsystem&amp;c=loggedin&amp;v=v3&amp;l=long</code> 和别名 <code>https://tinyurl.com/y7keocwj</code>，通过访问别名，最终可以跳转到原始 URL。</p></li><li><p><strong>候选人</strong>：服务的流量有多大？</p></li><li><p><strong>面试官</strong>：每天生成 1 亿条短链接。</p></li><li><p><strong>候选人</strong>：短链接的长度有多短？</p></li><li><p><strong>面试官</strong>：越短越好。</p></li><li><p><strong>候选人</strong>：短链接支持哪些字符？</p></li><li><p><strong>面试官</strong>：数字和字母。</p></li><li><p><strong>候选人</strong>：短链接是否支持更新或删除？</p></li><li><p><strong>面试官</strong>：为了简化设计，我们假设短链接不可更新或删除。</p></li></ul><h3 id="其他非功能需求" tabindex="-1"><a class="header-anchor" href="#其他非功能需求" aria-hidden="true">#</a> 其他非功能需求</h3><ul><li>高可用性</li><li>可扩展性</li><li>容错能力</li></ul><h3 id="粗略计算" tabindex="-1"><a class="header-anchor" href="#粗略计算" aria-hidden="true">#</a> 粗略计算</h3><ul><li><strong>每天生成的短链接数量</strong>：1 亿条，即每秒约 1200 条。</li><li><strong>读写比例</strong>：假设读写比为 10:1，则每秒大约 12000 次读取。</li><li><strong>支持 10 年的存储量</strong>：总计需要支持约 3650 亿条记录。</li><li><strong>平均 URL 长度</strong>：100 字符。</li><li><strong>10 年的存储需求</strong>：约 36.5 TB。</li></ul><h2 id="第二步-提出高层设计并获得认可" tabindex="-1"><a class="header-anchor" href="#第二步-提出高层设计并获得认可" aria-hidden="true">#</a> 第二步：提出高层设计并获得认可</h2><h3 id="api-设计" tabindex="-1"><a class="header-anchor" href="#api-设计" aria-hidden="true">#</a> API 设计</h3><p>设计一个 REST API，包含以下两个端点：</p><ol><li><p><code>POST api/v1/data/shorten</code><br> 接收长链接并返回短链接。</p></li><li><p><code>GET api/v1/shortURL</code><br> 根据短链接返回对应的长链接，用于 HTTP 重定向。</p></li></ol><h3 id="url-重定向" tabindex="-1"><a class="header-anchor" href="#url-重定向" aria-hidden="true">#</a> URL 重定向</h3><p>流程如下：</p><figure><img src="'+n+'" alt="tinyurl-example" tabindex="0" loading="lazy"><figcaption>tinyurl-example</figcaption></figure><h4 id="_301-和-302-状态码的区别" tabindex="-1"><a class="header-anchor" href="#_301-和-302-状态码的区别" aria-hidden="true">#</a> 301 和 302 状态码的区别：</h4><ul><li><strong>301（永久重定向）</strong>：表示 URL 永久指向新 URL，浏览器会在后续调用中绕过 tinyurl 服务。</li><li><strong>302（临时重定向）</strong>：表示 URL 暂时移动到新 URL，浏览器不会在后续调用中绕过 tinyurl 服务。</li></ul><p><strong>选择建议</strong>：</p><ul><li>如果希望减轻服务器负担，选择 301。</li><li>如果需要分析数据（如点击率），选择 302。</li></ul><p><strong>实现方式</strong>：<br> 最简单的重定向方法是使用内存中的哈希表存储 <code>&lt;shortURL, longURL&gt;</code> 映射。</p><h3 id="url-缩短" tabindex="-1"><a class="header-anchor" href="#url-缩短" aria-hidden="true">#</a> URL 缩短</h3><p>实现 URL 缩短需要找到合适的哈希函数，它应支持将长链接映射为短链接，并能逆向映射回原始链接。<br> 更多细节将在详细设计中讨论。</p><h2 id="第三步-深入设计" tabindex="-1"><a class="header-anchor" href="#第三步-深入设计" aria-hidden="true">#</a> 第三步：深入设计</h2><h3 id="数据模型" tabindex="-1"><a class="header-anchor" href="#数据模型" aria-hidden="true">#</a> 数据模型</h3><p>简单实现可以使用内存中的哈希表，但存在以下问题：</p><ol><li>内存不足。</li><li>数据在服务器重启后无法持久化。</li></ol><p>改进方案：使用简单的关系型数据库表。<br> 示例表结构如下：</p><figure><img src="'+l+'" alt="url-table" tabindex="0" loading="lazy"><figcaption>url-table</figcaption></figure><h3 id="哈希函数" tabindex="-1"><a class="header-anchor" href="#哈希函数" aria-hidden="true">#</a> 哈希函数</h3><p>短链接字符集为 <code>[0-9a-zA-Z]</code>，共 62 种字符。</p><p>为了支持 3650 亿条记录，计算哈希值最小长度：</p><ul><li>解方程 <code>62^n &gt;= 3650 亿</code>，得出 <code>n=7</code>，可支持约 3.5 万亿条记录。</li></ul><h4 id="哈希实现方式" tabindex="-1"><a class="header-anchor" href="#哈希实现方式" aria-hidden="true">#</a> 哈希实现方式</h4><ol><li><p><strong>基于哈希 + 冲突检测</strong><br> 使用 MD-5 或 SHA256 截取前 7 个字符。若冲突，则在输入字符串中加入填充再重新计算。</p><p>示例冲突检测机制：</p><figure><img src="'+s+'" alt="hash-collision-mechanism" tabindex="0" loading="lazy"><figcaption>hash-collision-mechanism</figcaption></figure><p><strong>问题</strong>：每次需查询数据库以检测冲突，可通过布隆过滤器优化。</p></li><li><p><strong>基于 Base62 编码</strong><br> 直接将唯一 ID 转换为所需的 62 进制字符串。</p></li></ol><p><strong>两种方式的比较</strong>：</p>',35),p=i('<table><thead><tr><th>哈希 + 冲突检测</th><th>Base62 编码</th></tr></thead><tbody><tr><td>短链接长度固定</td><td>短链接长度不固定，随 ID 增大</td></tr><tr><td>不需要唯一 ID 生成器</td><td>依赖唯一 ID 生成器</td></tr><tr><td>可能存在冲突，需要额外处理</td><td>不存在冲突，因为 ID 唯一</td></tr><tr><td>无法直接推断下一个短链接，有助于提高安全性</td><td>可以推断下一个短链接（如 ID 递增），可能存在安全风险</td></tr></tbody></table><h3 id="url-缩短流程" tabindex="-1"><a class="header-anchor" href="#url-缩短流程" aria-hidden="true">#</a> URL 缩短流程</h3><p>为了简化服务，我们选择使用 Base62 编码。<br> 完整流程如下：</p><figure><img src="'+o+'" alt="url-shortening-deep-dive" tabindex="0" loading="lazy"><figcaption>url-shortening-deep-dive</figcaption></figure><p>在分布式环境下，可使用 Twitter 的 Snowflake 算法生成唯一 ID。</p><h3 id="url-重定向流程" tabindex="-1"><a class="header-anchor" href="#url-重定向流程" aria-hidden="true">#</a> URL 重定向流程</h3><p>为提高读取性能，引入缓存：</p><figure><img src="'+d+'" alt="url-redirection-deep-dive" tabindex="0" loading="lazy"><figcaption>url-redirection-deep-dive</figcaption></figure><p><strong>具体步骤</strong>：</p><ol><li>用户点击短链接。</li><li>负载均衡器将请求转发到某个服务实例。</li><li>若短链接存在于缓存中，直接返回长链接。</li><li>若缓存中未命中，则从数据库获取长链接并存入缓存；若数据库中未找到，则返回“短链接不存在”错误。</li></ol><h2 id="第四步-总结" tabindex="-1"><a class="header-anchor" href="#第四步-总结" aria-hidden="true">#</a> 第四步：总结</h2><p>我们讨论了以下内容：</p><ol><li>API 设计。</li><li>数据模型。</li><li>哈希函数。</li><li>URL 缩短。</li><li>URL 重定向。</li></ol><h3 id="额外讨论点" tabindex="-1"><a class="header-anchor" href="#额外讨论点" aria-hidden="true">#</a> 额外讨论点</h3><ul><li><strong>速率限制</strong>：引入速率限制器，防止恶意用户过多请求短链接。</li><li><strong>Web 服务器扩展</strong>：由于服务无状态，可通过增加服务实例轻松扩展。</li><li><strong>数据库扩展</strong>：常见方法包括数据复制和分片。</li><li><strong>分析功能</strong>：集成分析功能，提供点击次数等商业洞察。</li><li><strong>高可用性与一致性</strong>：分布式系统的核心需求。</li></ul>',15);function c(u,f){return e(),t("div",null,[g,a(" prettier-ignore "),p])}const b=r(h,[["render",c],["__file","28_design_a_url_shortener.html.vue"]]);export{b as default};
